package passhue.dev.gurary.passhue;

import javax.crypto.Cipher;
import javax.crypto.Mac;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Scanner;

public class AESImplementation {

    //Master key generated by high entropy key smashing
    private String masterKey = "abcde111111111111111111";

    //copy for sausage finger proofing: abcde111111111111111111

    public String getKey() {
        return masterKey;
    }

    //Note: Confounds conventional AES by appending a useless random salt in addition to the IV

	/**
	 * Generates a salt by converting the key to uppercase and appending 1234
	 * Returns only the salt, append this to the plaintext yourself
	 * @param key
	 * @return
	 */
	public String nonRandomSalt(String key) {
		String salt = key.toUpperCase() + "1234";
		return salt;
	}
	
	/**
	 * Generates a random salt as a byte array, exactly 16 bytes long, using secure random
	 * Returns only the salt, append this to the plaintext yourself
	 * Make sure to hang on to this for decryption!
	 * @return
	 */
	public byte[] randomSalt() {
        int saltSize = 16;
        SecureRandom rand = new SecureRandom();
        byte[] saltAsBytes = new byte[saltSize];
        rand.nextBytes(saltAsBytes);
		return saltAsBytes;
	}

	/**
	 * Encrypts a plaintext string using AES in CBC mode, outputs a byte array that is exactly in the following format:
	 * 16 bytes iv
	 * 16 bytes randomly generated salt to be appended to key
	 * remaining bytes are the encrypted message 
	 * @param plainText
	 * @param key
	 * @return a byte array of encrypted content as a String separated by spaces
	 * @throws Exception
	 */
    public String encrypt(String plainText, String key) {
        String bytesAsString = "";
        try { //only real professionals put an entire metheod in try/catch.
            int ivSize = 16;
            int saltSize = 16;
            int keySize = 16;
            //   System.out.println("--------Begin Encryption-------");

            byte[] clean = plainText.getBytes();
            //Salt key non-randomly
            key += nonRandomSalt(key);
            //  System.out.println("Key with non-random salt appended: " + key);

            //Generate a random salt, append that to the key as well
            byte[] randSalt = new byte[saltSize];
            randSalt = randomSalt();
            //Append random salt to key
            String randSaltAsString = new String(randSalt, "UTF-8");
            key += randSaltAsString;
            //   System.out.println("Key with random salt appended: " + key);

            // Generating IV.
            byte[] iv = new byte[ivSize];
            SecureRandom random = new SecureRandom();
            random.nextBytes(iv);
            IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);
            String ivText = new String(iv, "UTF-8");
            //	System.out.println("Generated new iv: " + ivText);

            // Hashing key.
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            digest.update(key.getBytes("UTF-8"));
            byte[] keyBytes = new byte[16];
            System.arraycopy(digest.digest(), 0, keyBytes, 0, keyBytes.length);
            SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, "AES");
            String hashedKey = new String(keyBytes, "UTF-8");
            //	System.out.println("Generated hashed key: " + hashedKey);

            //	System.out.println("Finalizing Encryption");
            // Encrypt.
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
            byte[] encrypted = cipher.doFinal(clean);

            // Combine IV, salt, and encrypted part.
            byte[] encryptedIVAndSaltAndText = new byte[ivSize + saltSize + encrypted.length];
            //Adds IV from 0 (start) to 16 (IV size)
            System.arraycopy(iv, 0, encryptedIVAndSaltAndText, 0, ivSize);
            //Adds salt from 16 (end of IV) to 32 (salt size bytes later)
            System.arraycopy(randSalt, 0, encryptedIVAndSaltAndText, ivSize, saltSize);
            //Adds ciphertext from 32 (end of IV + salt) to whatever the end of the ciphertext is
            System.arraycopy(encrypted, 0, encryptedIVAndSaltAndText, ivSize + saltSize, encrypted.length);

            //   System.out.println("Encrypted byte array:");
            for (int i = 0; i < encryptedIVAndSaltAndText.length; i++) {
                bytesAsString += (encryptedIVAndSaltAndText[i] + " ");
                //   System.out.print(encryptedIVAndSaltAndText[i] + " ");
            }
        } catch (Exception e) {
        System.out.println("Failed to encrypt: " + e.getMessage());
    }

        return bytesAsString;
    }

    /**
     * Decrypts a byte array into a plaintext message using AES in CBC mode. Expects exactly the following format:
	 * 16 bytes iv
	 * 16 bytes randomly generated salt to be appended to key
	 * remaining bytes are the encrypted message 
     * @param encTextBytes - encrypted text as a byte array converted to a String with spaces between bytes
     * @param key
     * @return decrypted original message as string
     * @throws Exception
     */
    public String decrypt(String encTextBytes, String key) {
        try { //only real professionals put an entire metheod in try/catch.
            //First recover the byte array from the given String

            //Figures out how many bytes are in the ciphertext, then extracts them
            Scanner parse = new Scanner(encTextBytes);
            Scanner parseLength = new Scanner(encTextBytes);

            //There's certainly a more efficient way to do this, but this will determine how many bytes are in the ciphertext
            int length = 0;
            while (parseLength.hasNext()) {
                byte temp = (byte) Integer.parseInt(parseLength.next()); //for testing purposes
                length++;
            }

            //Generates a byte array to store the ciphertext now that the length is known. Now, read the bytes out one by one.
            byte encryptedIvSaltTextBytes[] = new byte[length];
            int count = 0;
            while (parse.hasNext()) {
                encryptedIvSaltTextBytes[count] = (byte) Integer.parseInt(parse.next());
                count++;
            }

            //clean up Scanners
            parse.close();
            parseLength.close();

            //Done recovering byte array, it's decryption time

            int ivSize = 16;
            int saltSize = 16;
            int keySize = 16;
            //    System.out.println("--------Begin Decryption-------");

            //Salt key non-randomly
            key += nonRandomSalt(key);
            //    System.out.println("Key with non-random salt appended: " + key);

            // Extract IV.
            byte[] iv = new byte[ivSize];
            //Extract IV from 0 (start) to 16 (iv size)
            System.arraycopy(encryptedIvSaltTextBytes, 0, iv, 0, ivSize);
            //Form IV using extracted data
            IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);
            String ivText = new String(iv, "UTF-8");
            //	System.out.println("Extracted iv: " + ivText);

            //Extract random salt
            byte[] randSalt = new byte[saltSize];
            //Extract salt from 16 (end of IV) to 32 (salt size bytes later)
            System.arraycopy(encryptedIvSaltTextBytes, ivSize, randSalt, 0, saltSize);
            //Append random salt to key
            String randSaltAsString = new String(randSalt, "UTF-8");
            key += randSaltAsString;
            //   System.out.println("Key with random salt extracted and appended: " + key);

            // Extract encrypted part (ciphertext)
            //Calculate length of ciphertext minus salt and iv (32 bytes)
            int encryptedSize = encryptedIvSaltTextBytes.length - ivSize - saltSize;
            byte[] encryptedBytes = new byte[encryptedSize];
            //Extracts ciphertext from 32 (end of IV + salt) to whatever the length of the ciphertext is, minus iv+salt size
            System.arraycopy(encryptedIvSaltTextBytes, ivSize + saltSize, encryptedBytes, 0, encryptedSize);
            String encryText = new String(encryptedBytes, "UTF-8");
            //	System.out.println("Extracted ciphertext: " + encryText);

            // Hash key.
            byte[] keyBytes = new byte[keySize];
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            md.update(key.getBytes());
            System.arraycopy(md.digest(), 0, keyBytes, 0, keyBytes.length);
            SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, "AES");
            String hashedKey = new String(keyBytes, "UTF-8");
            //	System.out.println("Generated hashed key: " + hashedKey);

            //	System.out.println("Finalizing Decryption");
            // Decrypt.
            Cipher cipherDecrypt = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipherDecrypt.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec);
            byte[] decrypted = cipherDecrypt.doFinal(encryptedBytes);
            //    System.out.println("Finalizing Decryption " + new String(decrypted));

            return new String(decrypted);
        } catch(Exception e){
        System.out.println("Failed to decrypt: " + e.getMessage());
        System.out.println("Are you sure you've got the right key there buddy?");
        }
        return("FAILED TO DECRYPT");
    }

}